## Цифровая кафедра | Приоритет 2030 | Web-разработка

### Python tasks

#### 1. Синтаксис. Ввод и вывод данных 
Напишите скрипт, который считывает строку с клавиатуры. Выведите на экран "привет", если введенная строка совпадает со строкой "привет" или "здравствуйте". Если введено что угодно другое, ничего выводить не нужно.

#### 2. Синтаксис. Сложение четных чисел
На вход с клавиатуры подаются числа (по одному). Нужно вывести на экран сумму всех четных чисел. Ввод прекращается, если введена пустая строка (""). При любой ситауации, когда не попадаются четные числа, вывести на экран нужно 0 (например, числа не были введены вообще или были введены только нечетные числа).

#### 3. Строки. Замена символов
С клавиатуры вводится строка. В строке заменить пробелы звездочкой. Если встречается подряд несколько пробелов, то их следует заменить одним знаком "*", пробелы в начале и конце строки удалить.

#### 4. Строки. Поиск подстрок
С клавиатуры вводится строка, а затем - подстрока. В строке найти все слова, в которых содержится заданная подстрока, и вывести эти слова целиком. Если слова повторяются, вывести все повторения.

#### 5. Коллекции. Списки
С клавиатуры подается 5 чисел, разделенных концом строки. Нужно вывести их на экран от большего к меньшему, также разделяя их концом строки.

#### 6. Коллекции. Множества
С клавиатуры вводится строка, содержащая произвольное количество слов через запятую и пробел. Слова могут повторяться. Нужно вывести на экран все слова в алфавитном порядке по одному разу, также через пробел и запятую.

#### 7. Коллекции. Словари
С клавиатуры вводятся слова через запятую с пробелом. Выведите на экран три наиболее часто встречаемых слова, вместе с количеством этих слов. Количество должно быть отделено от слова двоеточием и пробелом. Каждая пара слово-количество должна быть выведена на отдельной строчке. Для простоты гарантируется, что в строке нет слов с одинаковой встречаемостью.

#### 8. Даты
С клавиатуры вводится дата в формате DD-MM-YYYY. Нужно вывести дату начала недели, к которой относится введенная дата (дата понедельника недели), в таком же формате.

#### 9. Функции. Аргументы 1
Допустим, ваша компания каждый месяц выделяет некоторую сумму денег на подарки сотрудникам ко дню рождения. Каждый месяц эта сумма разная. Также у вас есть список дней рождения сотрудников. Вам нужно написать удобный инструмент для того, чтобы сотрудники могли понять, сколько денег им ждать на день рождения, если известно, какой бюджет выделяется на месяц и для какого месяца производится подсчет. Для этого напишите функцию gift_count, которая будет принимать:

бюджет, который выделяется компанией на месяц
номер месяца, на который нужно произвести расчет
словарь, где ключи - это имена сотрудников, а значения - datetime.date с датой рождения сотрудника.
Функция должна вывести на экран фразу (цифры должны быть подставлены в соответствии со значениями аргументов):

Именинники в месяце 5: Иванов Иван Иванович (01.05.1989), Петров Петр Петрович (06.05.1998). При бюджете 20000 они получат по 10000 рублей.

Если в ответе получается не целое число, округлите его до меньшего целого. Именинники должны быть выведены в порядке дня рождения по возрастанию (не полной даты рождения, а именно дня). Если в выбранном месяце нет именинников, должна быть выведена строка "В этом месяце нет именинников."

#### 10. Функции. Аргументы 2
Вам нужно написать функцию lists_sum, которая принимает произвольное количество списков чисел, и возвращает сумму всех этих чисел. Предусмотрите дополнительный аргумент unique, который по умолчанию равен False, но если в функцию подается unique=True, то функция должна вернуть сумму всех уникальных чисел из всех списков. Если поданы только пустые списки или списки чисел вообще не поданы в функцию, то считать сумму чисел нулём.

#### 11. Функции. Переиспользование кода
Вы с друзьями периодически собираетесь на лавке у подъезда выпить чаю с баранками. Каждый раз собирается разное количество человек, которое должно скинуть по n рублей на мероприятие. Также у вас в компании есть общак, в который можно докинуть денег, а можно взять. Все транзакции в общак логируются, т.е. у вас есть информация о каждом переводе денег в/из общака для каждого из друзей. Ваша задача - посчитать, сколько денег должен каждый из собравшихся на мероприятие друзей на момент начала мероприятия. Будем считать, что все деньги проходят через общак, поэтому у каждого друга к началу мероприятия уже есть некоторый "баланс" в общаке.

Формат хранения данных
Все операции с деньгами хранятся в базе данных и приходят к вам в виде списка словарей вида:

    {"name": "Василий", "amount": 500},
    {"name": "Петя", "amount": 100},
    {"name": "Василий", "amount": -300},
]
где name - имя друга (считаем, что всех зовут по-разному), amount - сумма, которая добавлена в общак. Если сумма отрицательная - это значит, что друг взял деньги из общака. Также считаем, что скидываются суммы в рублях без копеек.

Вам нужно описать две функции.
get_balance(name, transactions) -> int
функция, которая возвращает текущий баланс друга с именем name, исходя из списка транзакций transactions. Если имя name ни разу не встречается в списке transactions, считаем, что баланс этого друга в общаке равен 0 рублей.
count_debts(names, amount, transactions) -> dict
функция, которая принимает список имен присутствующих на мероприятии друзей names, стоимость баранок и чая на человека amount, а также список транзакций в общак transactions. Вернуть эта функция должна словарь вида {"имя_друга": 100}, где 100 - это количество денег, которое он должен скинуть на мероприятие. Если на балансе друга больше денег, чем требуется на мероприятие, то он должен 0 рублей.

#### 12. Регулярные выражения. Номер телефона и электронная почта
Написать функцию, которая на вход принимает строку, а на выход выдает булево значение (True или False), которое истинно, если полученная строка соответствует российскому номеру телефона или адресу электронной почты.

Сигнатура функции:

check_string(string) -> bool

#### 13. Файлы
Напишите функцию get_popular_name_from_file(filename), которая считывает файл, в котором в каждой строке записаны имя и фамилия через пробел. filename - это имя файла, в котором записаны эти имена. Вам нужно вернуть строку - самое популярное имя в файле. Если таких имен несколько, они должны быть перечислены через запятую внутри строки в алфавитном порядке.

#### 14. Парсинг JSON
Задачи, аналогичные этой, часто встречаются в реальной веб-разработке. Будем получать и отдавать JSONы. К вам поступают данные в виде json-строки, в которых содержится список людей. Для каждого человека описаны различные его параметры, но вам нужно посчитать просто средний возраст всех людей из списка. Напишите функцию mean_age(json_string), которая принимает json строку, считает средний возраст людей из входных данных и возвращает новую json-строку в том формате, который указан ниже.

#### 15. Классы 1. Калькулятор
Опишите класс Calculator, который будет реализовывать следующие методы и поля:

sum(self, a, b) - сложение чисел a и b
sub(self, a, b) - вычитание
mul(self, a, b) - умножение
div(self, a, b, mod=False) - деление. Если параметр mod == True, то метод должен возвращать остаток от деления вместо деления. По умолчанию mod=False.
history(self, n) - этот метод должен возвращать строку с операцией по ее номеру относительно текущего момента (1 - последняя, 2 - предпоследняя). Формат вывода: sum(5, 15) == 20
last - строка того же формата, что в предыдущем пункте, в которой содержится информация о последней операции по всем созданным объектам калькулятора. Т.е. это последняя операция последнего использованного объекта калькулятор. Если операций пока не было, то None.
clear(cls) - метод, который очищает last, т.е. присваивает ему значение None.

#### 16. Классы 2. Кошельки
Написать классы, которые будут использованы как счета в банке. Каждый счет - в своей валюте. Соответственно, у каждого объекта счета должны быть атрибуты с суммой денег, хранящихся на нём, и название кошелька. Каждый класс счета должен в себе хранить коэффициент отношения стоимости своей валюты к базовой валюте.

Нам понадобится один базовый класс BaseWallet, в котором будут реализованы общие для всех валютных счетов методы, и три класса для конкретных валютных счетов: RubbleWallet, DollarWallet, EuroWallet. Будем считать коэффициентами отношения валют к базовой валюте:

Рубль: 1
Доллар: 60
Евро: 70
Протокол взаимодействия объектов следующий:

RubbleWallet("Первый кошелек", 10), где "Первый кошелек" - это название кошелька, а 10 - сумма денег на нём.
аналогичные конструкторы для других счетов
RubbleWallet("X", 10) + 20 == RubbleWallet("X", 30) - при сложении с числом считаем, что это та же валюта.
RubbleWallet("X", 10) += 20 - должен поддерживаться и такой синтаксис
20 + RubbleWallet("X", 10) == RubbleWallet("X", 30) - radd для чисел
RubbleWallet("X", 20) + DollarWallet("D", 10) == RubbleWallet("X", 620) - конвертация валюты при сложении счетов.
DollarWallet("D", 2) + RubbleWallet("X", 60) == DollarWallet("D", 3) - результат - в валюте первого слагаемого.
DollarWallet("D", 2) += RubbleWallet("X", 60) - здесь тоже должен поддерживаться этот синтаксис.
предыдущие 6 пунктов реализовать и для вычитания
RubbleWallet("X", 10) * 20 == RubbleWallet("X", 200) - умножение на число
RubbleWallet("X", 10) *= 20 - тоже с таким синтаксисом
те же 2 пункта для деления
20 * RubbleWallet("X", 10) == RubbleWallet("X", 200) - умножение числа на кошелек
DollarWallet("A", 15) == DollarWallet("B", 15): два объекта равны, если у них совпадает тип кошелька и сумма на счете.
RubbleWallet("X", 100).spend_all() - для любого типа кошелька релизовать функцию, которая обнуляет баланс, если он положительный
DollarWallet("X", 1).to_base() == 60 - эта функция должна возвращать число денег в кошельке в базовой валюте
print(DollarWallet("Q", 150)) - должна выводить строку: 'Dollar Wallet Q 150' (и аналогично Rubble и Euro для остальных кошельков)
У каждого объекта должны быть доступны атрибуты:

name - название кошелька
amount - количество денег на счете
exchange_rate - коэффициент стоимости валюты к базовой

#### 17. Исключения
Напишем часть сервиса, который будет помогать бронировать переговорки в офисе. Для этого опишем класс Booking - его объекты будут содержать информацию о конкретном бронировании, а также вспомогательную функцию create_booking, которая будет создавать новый объект бронирования и записывать информацию о бронировании в базу данных бронирований через предоставляемое API. Возвращать она должна будет статус создания бронирования (получилось или переговорка уже занята) и информацию о брони в формате JSON. Ниже - подробности.

Класс Booking должен обладать следующим функционалом.

конструктор должен принимать три аргумента в следующем порядке: название переговорки, datetime начала брони и datetime конца брони
внутри конструктора, если datetime конца брони оказался раньше, чем datetime начала, нужно вызвать исключение ValueError
Также у объектов этого класса должны быть следующие поля (рекомендую сделать часть из них в виде проперти):

room_name
название переговорки, полученное из конструктора
start
datetime начала брони. Должна быть возможность назначить новое время начала уже созданной брони
end
datetime конца брони. Должна быть возможность назначить новое время конца уже созданной брони
duration
длительность бронирования в минутах (гарантируется, что длительность любой встречи кратна одной минуте, поэтому это должно быть целое число)
start_date
дата начала брони в формате YYYY-MM-DD (строка)
end_date
дата конца брони в формате YYYY-MM-DD (строка)
start_time
время начала брони в формате HH-MM (строка)
end_time
время конца брони в формате HH-MM (строка)
Функция create_booking должна обладать следующей сигнатурой:

create_booking(room_name, start, end) -> str,

где аргументы - это те же аргументы, которые принимает конструктор Booking, а выходная строка - это json определенного формата, который описан чуть ниже по тексту.

Будем считать, что взаимодействие с базой данных у нас уже описано нашим коллегой в соседнем файле api.py. В нем есть уже готовая функция register_booking, которая:

принимает на вход объект класса Booking
возвращает True, если бронирование получилось создать
возвращает False, если мы пытаемся забронировать уже занятую в это время переговорку
если такой переговорки не существует, вызывается KeyError
Таким образом, в том же файле, что и класс Booking, вам нужно описать фукнцию create_booking, которая:

обладает сигнатурой create_booking(room_name, start, end) -> str, где аргументы - те же, что и в конструкторе Booking
в самом начале своей работы выводит на экран текст: Начинаем создание бронирования
внутри функции создается объект класса Booking, а также вызывается функция register_booking, которая принимает на вход созданный объект. Должны быть обработаны все случаи работы register_booking: True, False и KeyError. Сделать это поможет конструкция try-except
перед выходом из функции должно выводиться на экран сообщение Заканчиваем создание бронирования. Это должно происходить в любом случае, даже если мы попытались создать бронирование с неверными датами и получили ValueError (см. описание класса Booking). Для этого рекомендую использовать блок finally, в котором описать этот print
Функция должна возвращать json-строку с ответом, в котором будут содержаться следующие поля:

created: true/false, получилось ли забронировать комнату. Если возникло KeyError, то нужно здесь записать false
msg: сообщение с пояснениями. Сообщение должно быть одним из следующих: Бронирование создано, Комната занята, Комната не найдена. Сообщение выбирается на основе того, что вернет функция register_booking
booking
это бронирование в виде json-строки. Должны содержаться поля: room_name, duration, start_date, end_date, start_time, end_time.

#### 18. Декораторы 1
В первом задании курса предлагается решить классическую задачу с собеседований по питону - написать декоратор, который вычисляет время выполнения оборачиваемой функции. Итак, требования к декоратору:

декоратор должен называться time_decorator
он должен вычислять время в секундах, в течение которого выполняется обернутая функция при ее вызове. Количество секунд должно быть выведено сразу после выполнения оборачиваемой функции. Количество секунд следует округлять до целого числа и выводить целое число
после оборачивания функция должна возвращать тот же результат, который возвращала исходная функция
пробрасывать аргументы из декоратора в функцию необязательно для выполнения этого задания

#### 19. Декораторы 2
В этом задании требуется написать фабрику декораторов, которые будут логировать вызовы функций. Чтобы не усложнять, в качестве журнала событий будем использовать списки. Требования к фабрике:

фабрика должна называться logging_decorator
при создании декоратора фабрика должна принять требуемый список-логгер в аргументах
обернутая функция должна возвращать тот же результат, который бы вернула оборачиваемая функция
при вызове обернутой функции в список-логгер должен добавляться словарь, в котором будут храниться название функции, список поданных аргументов, время вызова функции и результат, который она вернула. Формат словаря должен быть таким:
{
    'name': 'test_function',
    'arguments': {'a': 1, 'b': 2},
    'call_time': datetime.datetime(2021, 8, 1, 18, 18, 7, 849184),
    'result': 127
}

#### 20. Сеть
Здесь описано некоторое API, в котором есть доступ к базе пользователей, постов, комментариев и т.д. Методы, которые мы будем использовать, описаны в разделе Resources. Примеры использования API (правда, на JavaScript'е) описаны на том же сайте по ссылке Guide. Вам нужно для каждого пользователя посчитать количество оставленных постов и количество оставленных комментариев. Всю информацию для этого нужно стягивать GET-запросами по API. Результат нужно отправить в ваше пространство в https://webhook.site в виде POST-запроса, содержащего JSON следующего формата:

  "statistics": [
    {
      "id": 1,
      "username": "lolkek",
      "email": "user1@mail.dot",
      "posts": 125,
      "comments": 1358
    },
    {
      "id": 2,
      "username": "cheburek",
      "email": "user2@mail.dot",
      "posts": 5,
      "comments": 12
    }
  ]
}

